#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
staticDHCPd module: main

Purpose
=======
 Runs a staticDHCPd server.
 
Legal
=====
 This file is part of staticDHCPd.
 staticDHCPd is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 (C) Neil Tallim, 2013 <flan@uguu.ca>
"""
import logging
import logging.handlers
import os
import signal
import sys
import time
import traceback

import staticdhcpd
import libpydhcpserver
import staticdhcpd.system
import staticdhcpd.config

_logger = logging.getLogger('')

def _termHandler(signum, frame):
    """
    Cleanly shuts down this daemon upon receipt of a SIGTERM.
    
    @type signum: int
    @param signum: The kill-signal constant received. This will always be
        SIGTERM.
    @type frame: int
    @param frame: The stack-frame in which the kill-signal was received.
        This is not used.
    """
    _logger.warn("Received SIGTERM")
    staticdhcpd.system.ALIVE = False
    _logger.warn("System shutdown in progress")
    
def _hupHandler(signum, frame):
    """
    Reinitialises the system upon receipt of a SIGHUP.
    
    @type signum: int
    @param signum: The kill-signal constant received. This will always be
        SIGHUP.
    @type frame: int
    @param frame: The stack-frame in which the kill-signal was received.
        This is not used.
    """
    _logger.warn("Received SIGHUP")
    staticdhcpd.system.reinitialise()
    _logger.warn("System reinitialised")
    
def _daemonise():
    if os.fork(): #This is the parent
        sys.exit(0)
    os.setsid() #Ensure session semantics are configured
    os.chdir('/') #Avoid holding references to unstable resources
    
    #And lastly, clean up the base descriptors
    os.dup2(open('/dev/null', 'r').fileno(), sys.stdin.fileno())
    os.dup2(open('/dev/null', 'a+').fileno(), sys.stdout.fileno())
    os.dup2(open('/dev/null', 'a+', 0).fileno(), sys.stderr.fileno())
    
def _setupLogging(logger):
    """
    Attaches handlers to the given logger, allowing for universal access to resources.
    """
    formatter = logging.Formatter(
     "%(asctime)s : %(levelname)s : %(name)s:%(lineno)d[%(threadName)s] : %(message)s"
    )
    
    if not staticdhcpd.config.DAEMON: #Daemon-style execution disables console-based logging
        console_logger = logging.StreamHandler()
        console_logger.setLevel(getattr(logging, staticdhcpd.config.LOG_CONSOLE_SEVERITY))
        console_logger.setFormatter(formatter)
        logger.addHandler(console_logger)
        logger.info("Console-based logging online")
        
    if staticdhcpd.config.LOG_FILE: #Determine whether disk-based logging is desired
        logger.info("Configuring file-based logging for " + staticdhcpd.config.LOG_FILE + "...")
        if staticdhcpd.config.LOG_FILE_TIMESTAMP:
            #Rollover once per day, keeping the configured number of days' logs as history
            file_logger = logging.handlers.TimedRotatingFileHandler(
             staticdhcpd.config.LOG_FILE, 'D', 1, staticdhcpd.config.LOG_FILE_HISTORY
            )
            logger.info("Configured rotation-based logging, with history=" + str(staticdhcpd.config.LOG_FILE_HISTORY) + " days")
        else:
            #Keep writing to the specified file forever
            file_logger = logging.handlers.FileHandler(staticdhcpd.config.LOG_FILE)
            logger.info("Configured indefinite-growth logging")
        file_logger.setLevel(getattr(logging, staticdhcpd.config.LOG_FILE_SEVERITY))
        file_logger.setFormatter(formatter)
        logger.addHandler(file_logger)
        logger.info("File-based logging online")
        
    if staticdhcpd.config.EMAIL_ENABLED: #Add an SMTP handler
        smtp_handler = logging.handlers.SMTPHandler(
         (staticdhcpd.config.EMAIL_SERVER, staticdhcpd.config.EMAIL_PORT),
         staticdhcpd.config.EMAIL_SOURCE,
         staticdhcpd.config.EMAIL_DESTINATION,
         staticdhcpd.config.EMAIL_SUBJECT,
         credentials=(staticdhcpd.config.EMAIL_USER and (staticdhcpd.config.EMAIL_USER, staticdhcpd.config.EMAIL_PASSWORD) or None),
         timeout=staticdhcpd.config.EMAIL_TIMEOUT
        )
        logger.info("Configured SMTP-based logging for " + staticdhcpd.config.EMAIL_DESTINATION + " via " + staticdhcpd.config.EMAIL_SERVER + ":" + str(staticdhcpd.config.EMAIL_PORT))
        smtp_handler.setLevel(logging.CRITICAL)
        smtp_handler.setFormatter(formatter)
        logger.addHandler(smtp_handler)
        logger.info("SMTP-based logging online")
        
        
if __name__ == '__main__':
    #Ensure that pre-setup tasks are taken care of.
    staticdhcpd.config.init()
    
    if staticdhcpd.config.DAEMON:
        _daemonise()
        
    _setupLogging(_logger)
    for i in (
     "----------------------------------------",
     "----------------------------------------",
     "----------------------------------------",
     "----------------------------------------",
     "----------------------------------------",
     "System startup in progress",
     "staticDHCPd version " + staticdhcpd.VERSION,
     "libpydhcpserver version " + libpydhcpserver.VERSION,
     "Continuing with subsystem initialisation",
     "----------------------------------------",
    ):
        _logger.warn(i)
    del i
    
    _logger.debug("Writing pidfile...")
    pidfile_recorded = False
    try:
        pidfile = open(staticdhcpd.config.PID_FILE, 'w')
        pidfile.write(str(os.getpid()) + '\n')
        pidfile.close()
        os.chown(staticdhcpd.config.PID_FILE, staticdhcpd.config.UID, staticdhcpd.config.GID)
    except:
        _logger.error("Unable to write pidfile: %(file)s" % {'file': staticdhcpd.config.PID_FILE,})
    else:
        pidfile_recorded = True
        
    try:
        #Set signal-handlers.
        signal.signal(signal.SIGHUP, _hupHandler)
        _logger.debug("Installed SIGHUP handler")
        signal.signal(signal.SIGTERM, _termHandler)
        _logger.debug("Installed SIGTERM handler")
        
        #Initialise all system resources
        staticdhcpd.system.initialise()
        
        _logger.info("Changing runtime permissions to UID=%(uid)i, GID=%(gid)i..." % {
         'uid': staticdhcpd.config.UID,
         'gid': staticdhcpd.config.GID,
        })
        os.setregid(staticdhcpd.config.GID, staticdhcpd.config.GID)
        os.setreuid(staticdhcpd.config.UID, staticdhcpd.config.UID)
        
        _logger.warn("All subsystems initialised; serving")
        while staticdhcpd.system.ALIVE:
            time.sleep(1)
    except KeyboardInterrupt:
        _logger.warn("System shutdown requested via keyboard interrupt")
    except Exception:
        _logger.critical("System shutdown triggered by unhandled exception:\n" + traceback.format_exc())
    finally:
        if pidfile_recorded:
            _logger.debug("Unlinking pidfile...")
            try:
                os.unlink(staticdhcpd.config.PID_FILE)
            except:
                _logger.error("Unable to unlink pidfile: %(file)s" % {'file': staticdhcpd.config.PID_FILE,})
                