"""
Import this module from conf.py and call `provisionDynamic(mac)` to get dynamic
allocations, good for use in a single-DHCP-server environment. Do be aware that
no validation is performed to ensure that the DHCP request was legal, just that
it was well-formed. Malicious clients cannot compromise the server, but they
can trigger DoS behaviour. Given that there's nothing to gain, however, this is
probably a non-issue.

Please make changes to this module before using it in your environment. The
default settings are almost certainly good for nobody.

Consider setting 'renewal_time_value' and 'rebinding_time_value' to some number
very close to, if not equal to, your lease-time, to avoid having clients extend
leases longer than necessary; if you want a more persistent dynamic solution,
you should be using the ISC server. The best use-case for this is giving
unknown clients access to a guest subnet so they can be migrated to a static
context.

You can identify dynamic requests by using a unique subnet/serial pair and
checking for it in loadDHCPPacket(); the default pair this module provides is
('guest', 0).
"""
import collections
import logging
import threading
import time

_logger = logging.getLogger('conf.dynamism')

#Configure these variables as needed
###############################################################################
LEASE_TIME = 300 #seconds
SUBNET = 'guest'
SERIAL = 0

#Add any elements you want to the list, as dotted-quad-notation IPv4 addresses
IPS = set()
#Use patterns like this to add blocks of IPs; this covers .11-.254
IPS.update(['192.168.250.' + str(i) for i in xrange(11, 255)])

SUBNET_MASK = '255.255.255.0'
GATEWAY = '192.168.250.1'
BROADCAST_ADDRESS = '192.168.250.255'
DOMAIN_NAME = 'guestnet.example.org' #None to not have a default search-domain
DOMAIN_NAME_SERVERS = ('192.168.250.5', '192.168.250.6', '192.168.250.7') #Limit: 3
NTP_SERVERS = ('192.168.250.2', '192.168.250.3', '192.168.250.4') #Limit: 3
###############################################################################
#Don't touch anything else, unless you want to (it's your network, after all)

_IPS = collections.deque(sorted(IPS)) #Redefine the set of IPs as an initially-sorted deque for sanity
_IPS_LOCK = threading.Lock()
_DYNAMIC_MAP = {}
_DYNAMIC_MAP_LOCK = threading.Lock()

#Finalise common strings
_DOMAIN_NAME_SERVERS = ','.join(DOMAIN_NAME_SERVERS)
_NTP_SERVERS = ','.join(NTP_SERVERS)
_HOSTNAME_PATTERN = SUBNET + '-' + str(SERIAL) + '-'

def _cleanupLeases():
    current_time = time.time()
    dead_records = []
    for (mac, (expiration, ip)) in _DYNAMIC_MAP.items():
        if current_time - expiration > LEASE_TIME: #Kill it
            dead_records.append(mac)
            with _IPS_LOCK: #Put the IP back into the pool
                _IPS.append(ip)
                
    for mac in dead_records:
        del _DYNAMIC_MAP[mac]
        
def _dropLease(mac):
    ip = None
    match = _DYNAMIC_MAP.get(mac)
    if match: #Drop the lease and reclaim the IP
        ip = match[1]
        del _DYNAMIC_MAP[mac]
        with _IPS_LOCK:
            _IPS.append(ip)
    return ip
    
def _getLease(mac):
    ip = None
    match = _DYNAMIC_MAP.get(mac)
    if match: #Renew the lease and take the IP
        match[0] = time.time() + LEASE_TIME
        ip = match[1]
        
        _logger.debug("Extended lease of %(ip)s to %(mac)s until %(time).1f" % {
            'ip': ip,
            'mac': mac,
            'time': match[0],
        })
    else:
        with _IPS_LOCK:
            if _IPS:
                ip = _IPS.popleft()
                
        if ip:
            expiration = time.time() + LEASE_TIME
            _DYNAMIC_MAP[mac] = [expiration, ip]
            _logger.debug("Bound %(ip)s to %(mac)s until %(time).1f" % {
                'ip': ip,
                'mac': mac,
                'time': expiration,
            })
    return ip
    
def _queryLease(mac):
    match = _DYNAMIC_MAP.get(mac)
    if match:
        return match[1]
    return None
    
    
def _dynamicMethod(f):
    def wrappedMethod(*args, **kwargs):
        with _DYNAMIC_MAP_LOCK:
            _cleanupLeases() #Remove stale assignments
            ip = f(*args, **kwargs)
            if ip:
                return (
                 ip, _HOSTNAME_PATTERN + ip.replace('.', '-'),
                 GATEWAY, SUBNET_MASK, BROADCAST_ADDRESS,
                 DOMAIN_NAME, _DOMAIN_NAME_SERVERS,
                 _NTP_SERVERS, LEASE_TIME,
                 SUBNET, SERIAL
                )
            return None
    return wrappedMethod
    
@_dynamicMethod
def _allocate(mac):
    """
    If you need to reject a MAC, return None.
    """
    ip = _getLease(mac)
    if not ip:
        _logger.warn("No IP available for assignment to %(mac)s" % {
         'mac': mac,
        })
    return ip
    
@_dynamicMethod
def _inform(mac, client_ip):
    """
    If you need to reject a MAC, return None.
    """
    return client_ip
    
@_dynamicMethod
def _reclaim(mac, client_ip):
    """
    If you need to reject a MAC, return None.
    """
    ip = _queryLease(mac)
    if not ip:
        _logger.warn("No IP assigned to %(mac)s" % {
         'mac': mac,
        })
        return None
    elif ip != client_ip:
        _logger.warn("IP assigned to %(mac)s, %(aip)s, does not match %(ip)s" % {
         'aip': ip,
         'ip': client_ip,
         'mac': mac,
        })
        return None
    return _dropLease(mac)
    
def handle(method, mac, client_ip):
    """
    Processes a dynamic request, returning a synthesised lease, if possible.
    
    @type method: basestring
    @param method: The DHCP method being invoked.
    @type mac: basestring
    @param mac: A human-readable MAC address.
    @type client_ip: tuple|None
    @param client_ip: The client's address, if not a provisioning request.
    
    @rtype: tuple(11)|None
    @return: A tuple of the following form, if processing succeeded, or None:
        (ip:basestring, hostname:basestring|None,
        gateway:basestring|None, subnet_mask:basestring|None,
        broadcast_address:basestring|None,
        domain_name:basestring|None, domain_name_servers:basestring|None,
        ntp_servers:basestring|None, lease_time:int,
        subnet:basestring, serial:int)
    """
    client_ip = client_ip and '.'.join(map(str, client_ip))
    
    _logger.info("Dynamic %(method)s from %(mac)s%(ip)s" % {
     'method': method,
     'mac': mac,
     'ip': client_ip and (' for %(ip)s' % {'ip': client_ip,}) or '',
    })
    
    if method == 'DISCOVER' or method.startswith('REQUEST:'):
        return _allocate(mac)
    if method == 'RELEASE' or method == 'DECLINE':
        return _reclaim(mac, client_ip)
    if method == 'INFORM':
        return _inform(mac, client_ip)
    
    _logger.info("%(method)s is unknown to the dynamic provisioning engine" % {
     'method': method,
    })
    return None
    